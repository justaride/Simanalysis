"""Integration tests using real generated fixture files.

These tests validate the entire analysis pipeline using realistic .package
and .ts4script files generated by create_fixtures.py.
"""

import pytest
from pathlib import Path

from simanalysis.parsers.dbpf import DBPFReader
from simanalysis.parsers.tuning import TuningParser
from simanalysis.parsers.script import ScriptAnalyzer
from simanalysis.analyzers.mod_analyzer import ModAnalyzer
from simanalysis.exceptions import DBPFError
from simanalysis.models import ConflictType, Severity


# Fixtures
@pytest.fixture
def fixtures_dir():
    """Path to fixtures directory."""
    return Path(__file__).parent.parent / "fixtures" / "sample_mods"


@pytest.fixture
def simple_mod(fixtures_dir):
    """Path to simple_mod.package."""
    return fixtures_dir / "simple_mod.package"


@pytest.fixture
def conflicting_mod_a(fixtures_dir):
    """Path to conflicting_mod_a.package."""
    return fixtures_dir / "conflicting_mod_a.package"


@pytest.fixture
def conflicting_mod_b(fixtures_dir):
    """Path to conflicting_mod_b.package."""
    return fixtures_dir / "conflicting_mod_b.package"


@pytest.fixture
def large_mod(fixtures_dir):
    """Path to large_mod.package."""
    return fixtures_dir / "large_mod.package"


@pytest.fixture
def empty_mod(fixtures_dir):
    """Path to empty.package."""
    return fixtures_dir / "empty.package"


@pytest.fixture
def corrupted_mod(fixtures_dir):
    """Path to corrupted_header.package."""
    return fixtures_dir / "corrupted_header.package"


@pytest.fixture
def truncated_mod(fixtures_dir):
    """Path to truncated.package."""
    return fixtures_dir / "truncated.package"


@pytest.fixture
def uncompressed_mod(fixtures_dir):
    """Path to uncompressed.package."""
    return fixtures_dir / "uncompressed.package"


@pytest.fixture
def script_simple(fixtures_dir):
    """Path to script_mod_simple.ts4script."""
    return fixtures_dir / "script_mod_simple.ts4script"


@pytest.fixture
def script_injection(fixtures_dir):
    """Path to script_mod_injection.ts4script."""
    return fixtures_dir / "script_mod_injection.ts4script"


@pytest.fixture
def script_conflicting(fixtures_dir):
    """Path to script_mod_conflicting.ts4script."""
    return fixtures_dir / "script_mod_conflicting.ts4script"


# Core Package Tests
class TestCorePackages:
    """Test parsing and analysis of core fixture packages."""

    def test_simple_mod_parsing(self, simple_mod):
        """Test parsing simple_mod.package."""
        reader = DBPFReader(simple_mod)

        # Read header
        header = reader.read_header()
        assert header.major_version == 2
        assert header.minor_version == 1
        assert header.index_count == 1

        # Read resources
        resources = reader.read_index()
        assert len(resources) == 1

        resource = resources[0]
        assert resource.instance == 0x11111111

        # Extract resource data
        data = reader.get_resource(resource)
        assert len(data) > 0

        # Parse as tuning
        parser = TuningParser()
        tuning = parser.parse(data)

        assert tuning.tuning_name == "buff_simple_happy"
        assert tuning.tuning_class == "Buff"
        assert tuning.instance_id == 0x11111111

    def test_conflicting_mod_a_parsing(self, conflicting_mod_a):
        """Test parsing conflicting_mod_a.package."""
        reader = DBPFReader(conflicting_mod_a)
        header = reader.read_header()

        assert header.major_version == 2
        assert header.index_count == 1

        resources = reader.read_index()
        resource = resources[0]

        assert resource.instance == 0xAAAAAAAA

        data = reader.get_resource(resource)
        parser = TuningParser()
        tuning = parser.parse(data)

        assert tuning.tuning_name == "buff_confident"
        assert tuning.instance_id == 0xAAAAAAAA

    def test_conflicting_mod_b_parsing(self, conflicting_mod_b):
        """Test parsing conflicting_mod_b.package."""
        reader = DBPFReader(conflicting_mod_b)
        header = reader.read_header()

        assert header.major_version == 2
        assert header.index_count == 1

        resources = reader.read_index()
        resource = resources[0]

        assert resource.instance == 0xAAAAAAAA  # Same as mod A!

        data = reader.get_resource(resource)
        parser = TuningParser()
        tuning = parser.parse(data)

        assert tuning.tuning_name == "buff_confident"
        assert tuning.instance_id == 0xAAAAAAAA

    def test_large_mod_parsing(self, large_mod):
        """Test parsing large_mod.package with 50 resources."""
        reader = DBPFReader(large_mod)
        header = reader.read_header()

        assert header.major_version == 2
        assert header.index_count == 50

        resources = reader.read_index()
        assert len(resources) == 50

        # Verify instance IDs are sequential
        for i, resource in enumerate(resources):
            expected_id = 0x22220000 + i
            assert resource.instance == expected_id

        # Extract and parse first resource
        data = reader.get_resource(resources[0])
        parser = TuningParser()
        tuning = parser.parse(data)

        assert tuning.tuning_name == "buff_large_mod_0"
        assert tuning.instance_id == 0x22220000

        # Extract and parse last resource
        data = reader.get_resource(resources[49])
        tuning = parser.parse(data)

        assert tuning.tuning_name == "buff_large_mod_49"
        assert tuning.instance_id == 0x22220031


# Edge Case Tests
class TestEdgeCases:
    """Test error handling with edge case fixtures."""

    def test_empty_package_error(self, empty_mod):
        """Test that empty.package raises appropriate error."""
        with pytest.raises(DBPFError, match="File too small"):
            reader = DBPFReader(empty_mod)
            reader.read_header()

    def test_corrupted_header_error(self, corrupted_mod):
        """Test that corrupted_header.package raises appropriate error."""
        with pytest.raises(DBPFError, match="Invalid DBPF magic"):
            reader = DBPFReader(corrupted_mod)
            reader.read_header()

    def test_truncated_package_error(self, truncated_mod):
        """Test that truncated.package raises appropriate error."""
        reader = DBPFReader(truncated_mod)
        reader.read_header()  # Header should read OK

        with pytest.raises(DBPFError, match="Index entry.*extends beyond index table"):
            reader.read_index()

    def test_uncompressed_package(self, uncompressed_mod):
        """Test that uncompressed.package is parsed correctly."""
        reader = DBPFReader(uncompressed_mod)
        header = reader.read_header()

        assert header.index_count == 1

        resources = reader.read_index()
        resource = resources[0]

        assert resource.instance == 0x33333333
        assert not resource.is_compressed

        data = reader.get_resource(resource)
        assert data == b"Uncompressed test data"


# Script Tests
class TestScriptFixtures:
    """Test script parsing and analysis."""

    def test_script_simple_parsing(self, script_simple):
        """Test that script_mod_simple.ts4script can be initialized."""
        # ScriptAnalyzer is initialized with the file path
        analyzer = ScriptAnalyzer(script_simple)
        assert analyzer is not None

    def test_script_injection_parsing(self, script_injection):
        """Test that script_mod_injection.ts4script can be initialized."""
        # ScriptAnalyzer is initialized with the file path
        analyzer = ScriptAnalyzer(script_injection)
        assert analyzer is not None

    def test_script_conflicting_parsing(self, script_conflicting):
        """Test that script_mod_conflicting.ts4script can be initialized."""
        # ScriptAnalyzer is initialized with the file path
        analyzer = ScriptAnalyzer(script_conflicting)
        assert analyzer is not None


# Conflict Detection Tests
class TestConflictDetection:
    """Test conflict detection using fixture files."""

    def test_tuning_conflict_detection(self, fixtures_dir):
        """Test that tuning conflicts are detected between mod A and B."""
        analyzer = ModAnalyzer()

        # Analyze only the conflicting mods
        conflicting_dir = fixtures_dir
        result = analyzer.analyze_directory(conflicting_dir)

        # Find conflicts (analyze_directory returns dict with conflicts)
        # The conflicts are resource-level conflicts detected
        assert len(result.conflicts) >= 1, "Should detect at least one conflict"

        # Verify we detected the conflict between mod A and B
        # Both mods modify instance ID 0xAAAAAAAA
        found_conflict = False
        for conflict in result.conflicts:
            if "conflicting_mod_a.package" in conflict.affected_mods and \
               "conflicting_mod_b.package" in conflict.affected_mods:
                found_conflict = True
                assert conflict.severity in [Severity.LOW, Severity.MEDIUM, Severity.HIGH]
                break

        assert found_conflict, "Should detect conflict between mod A and B"

    def test_script_conflict_detection(self, fixtures_dir):
        """Test that script conflicts are detected."""
        analyzer = ModAnalyzer()
        result = analyzer.analyze_directory(fixtures_dir)

        # Find script conflicts (if implemented)
        # Note: This depends on whether script conflict detection is implemented
        # For now, we just verify scripts are analyzed
        script_mods = [m for m in result.mods if m.path.suffix == ".ts4script"]
        assert len(script_mods) >= 3  # simple, injection, conflicting


# Full Pipeline Tests
class TestFullPipeline:
    """Test complete analysis pipeline on all fixtures."""

    def test_analyze_all_valid_fixtures(self, fixtures_dir):
        """Test analyzing all valid fixtures together."""
        analyzer = ModAnalyzer()
        result = analyzer.analyze_directory(fixtures_dir)

        # Should find valid mods (excluding edge cases that fail)
        # 4 packages + 3 scripts = 7 valid mods
        assert len(result.mods) >= 4  # At least the 4 valid packages

        # Should detect conflicts
        assert len(result.conflicts) >= 1

        # Performance metrics should be populated
        assert result.performance.total_size_mb > 0
        assert result.performance.total_resources >= 53  # 1+1+1+50
        assert result.performance.estimated_load_time_seconds >= 0

    def test_analyze_simple_mod_only(self, simple_mod):
        """Test analyzing directory containing simple mod."""
        analyzer = ModAnalyzer()
        result = analyzer.analyze_directory(simple_mod.parent)

        assert len(result.mods) >= 1

        # Find the simple mod in results
        simple_mods = [m for m in result.mods if m.name == "simple_mod.package"]
        assert len(simple_mods) == 1

        mod = simple_mods[0]
        assert mod.name == "simple_mod.package"
        assert mod.path == simple_mod

    def test_export_analysis_json(self, fixtures_dir, tmp_path):
        """Test exporting analysis results to JSON."""
        analyzer = ModAnalyzer()
        result = analyzer.analyze_directory(fixtures_dir)

        output_file = tmp_path / "analysis_result.json"
        analyzer.export_report(result, output_file, format="json")

        assert output_file.exists()
        assert output_file.stat().st_size > 0

        # Verify JSON is valid
        import json
        with open(output_file) as f:
            data = json.load(f)

        assert "mods" in data
        assert "conflicts" in data
        assert "summary" in data  # summary instead of performance
        assert len(data["mods"]) >= 4

    def test_export_analysis_txt(self, fixtures_dir, tmp_path):
        """Test exporting analysis results to TXT."""
        analyzer = ModAnalyzer()
        result = analyzer.analyze_directory(fixtures_dir)

        output_file = tmp_path / "analysis_result.txt"
        analyzer.export_report(result, output_file, format="txt")

        assert output_file.exists()
        assert output_file.stat().st_size > 0

        # Verify TXT contains expected sections
        content = output_file.read_text()
        assert "ANALYSIS REPORT" in content or "Mods Analyzed" in content


# Performance Tests
class TestPerformance:
    """Test performance characteristics with fixture data."""

    def test_large_mod_performance(self, large_mod):
        """Test parsing large_mod.package performance."""
        reader = DBPFReader(large_mod)
        header = reader.read_header()
        resources = reader.read_index()

        assert header.index_count == 50
        assert len(resources) == 50

    def test_full_analysis_performance(self, fixtures_dir):
        """Test full analysis pipeline performance."""
        analyzer = ModAnalyzer()
        result = analyzer.analyze_directory(fixtures_dir)

        assert len(result.mods) >= 4


# Resource Extraction Tests
class TestResourceExtraction:
    """Test resource extraction from packages."""

    def test_extract_all_resources_simple(self, simple_mod):
        """Test extracting all resources from simple_mod."""
        reader = DBPFReader(simple_mod)
        resources = reader.read_index()

        for resource in resources:
            data = reader.get_resource(resource)
            assert len(data) > 0
            assert isinstance(data, bytes)

    def test_extract_all_resources_large(self, large_mod):
        """Test extracting all 50 resources from large_mod."""
        reader = DBPFReader(large_mod)
        resources = reader.read_index()

        extracted_count = 0
        for resource in resources:
            data = reader.get_resource(resource)
            assert len(data) > 0
            extracted_count += 1

        assert extracted_count == 50


# Regression Tests
class TestRegression:
    """Regression tests to prevent future breakage."""

    def test_fixture_files_exist(self, fixtures_dir):
        """Verify all expected fixture files exist."""
        expected_files = [
            "simple_mod.package",
            "conflicting_mod_a.package",
            "conflicting_mod_b.package",
            "large_mod.package",
            "empty.package",
            "corrupted_header.package",
            "truncated.package",
            "uncompressed.package",
            "script_mod_simple.ts4script",
            "script_mod_injection.ts4script",
            "script_mod_conflicting.ts4script",
        ]

        for filename in expected_files:
            filepath = fixtures_dir / filename
            assert filepath.exists(), f"Missing fixture: {filename}"

    def test_fixture_sizes(self, fixtures_dir):
        """Verify fixture files have expected sizes."""
        # Core packages should be small but non-empty
        simple_mod = fixtures_dir / "simple_mod.package"
        assert simple_mod.stat().st_size > 200  # At least header + minimal resource

        # Large mod should be larger
        large_mod = fixtures_dir / "large_mod.package"
        assert large_mod.stat().st_size > 5000  # 50 resources

        # Edge cases
        empty_mod = fixtures_dir / "empty.package"
        assert empty_mod.stat().st_size == 0

        corrupted_mod = fixtures_dir / "corrupted_header.package"
        assert corrupted_mod.stat().st_size == 96  # Header size

    def test_no_unexpected_files(self, fixtures_dir):
        """Verify no unexpected files in fixtures directory."""
        allowed_extensions = {".package", ".ts4script"}
        allowed_names = {"README.md", ".gitkeep"}

        for filepath in fixtures_dir.iterdir():
            if filepath.is_file():
                if filepath.suffix not in allowed_extensions and filepath.name not in allowed_names:
                    pytest.fail(f"Unexpected file in fixtures: {filepath.name}")
